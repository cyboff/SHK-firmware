#include <Arduino.h>

//for display
#include <LedDisplay.h>
#include <stdio.h>
#include <stdarg.h>

//for EEPROM
#include <EEPROM.h>

// for ADC
#include <ADC.h>
// #include "RingBufferDMA.h"

// for SPI
#include <SPI.h>

//defaults EEPROM
#define MODEL_TYPE                                  50
#define MODEL_PROD_YEAR                             16
#define MODEL_SERIAL_NUMBER                         001
#define FW_MAJOR_VERSION                            0
#define FW_MINOR_VERSION                            1

#define DEFAULT_MODBUS_ID                           MODEL_SERIAL_NUMBER  // MODBUS ID slave range 1..247
#define DEFAULT_MODBUS_SPEED                        19200
#define DEFAULT_MODBUS_FORMAT                       SERIAL_8N1

#define DEFAULT_SET                                 0   // RELAY = 0 (REL1 || REL2), MAN1 = 1, MAN2 = 2
#define DEFAULT_GAIN_SET1                           16
#define DEFAULT_THRESHOLD_SET1                      30
#define DEFAULT_GAIN_SET2                           32
#define DEFAULT_THRESHOLD_SET2                      50


// EEPROM Addresses for signature code and version of firmware
#define EE_ADDR_MODEL_TYPE                           0x00 // WORD
#define EE_ADDR_MODEL_PROD_YEAR                      0x02 // WORD
#define EE_ADDR_MODEL_SERIAL_NUMBER                  0x04 // WORD
#define EE_ADDR_FW_MAJOR_VERSION                     0x06 // WORD
#define EE_ADDR_FW_MINOR_VERSION                     0x08 // WORD


// EEPROM Addresses for config
#define EE_ADDR_modbus_ID                            0x10 // WORD
#define EE_ADDR_modbus_Speed                         0x12 // WORD  speed/100 to fit 115200 to WORD
#define EE_ADDR_modbus_Format                        0x14 // WORD

#define EE_ADDR_set                                  0x20 // WORD
#define EE_ADDR_gain_set1                            0x22 // WORD
#define EE_ADDR_threshold_set1                       0x24 // WORD
#define EE_ADDR_gain_set2                            0x26 // WORD
#define EE_ADDR_threshold_set2                       0x28 // WORD



// Modbus - RS485

// assign the Arduino pin that must be connected to RE-DE RS485 transceiver

#define TXEN  2  // Serial1: RX1=0 TX1=1 TXEN=2

// SPI

#define SPI_LATCH 10

// Define pins for the LED display.
// You can change these, just re-wire your board:
#define dataPin 7              // 7 connects to the display's data in
#define registerSelect 6       // 6 the display's register select pin
#define clockPin 5             // 5 the display's clock pin
#define enable 4               // 4 the display's chip enable pin
#define reset 3                // 3 the display's reset pin

#define displayLength 8        // number of characters in the display

// create am instance of the LED display library:
LedDisplay myDisplay = LedDisplay(dataPin, registerSelect, clockPin, enable, reset, displayLength);
int brightness = 5;        // screen brightness

// LEDs and I/O

#define LED_POWER   16
#define LED_SIGNAL  15
#define LED_ALARM   14

#define PIN_BTN_A  17  //(digital pin)
#define PIN_BTN_B  18  //(digital pin)
#define TEST_IN     19
#define SET_IN      20

#define LASER       33
#define IR_LED      32
#define OUT_SIGNAL  8
#define OUT_ALARM_NEG   9 //negative output: 24V=>OK, 0V=>ALARM

// Keycodes
#define BTN_NONE             0 // No keys pressed
#define BTN_A                1 // Button A was pressed
#define BTN_B                2 // Button B was pressed
#define BTN_AH               3 // Button A was pressed and holded (BTN_HOLD_TIME) milisecons
#define BTN_BH               4 // Button B was pressed and holded (BTN_HOLD_TIME) milisecons
#define BTN_ABH              5 // Buttons A+B was pressed and holded (BTN_HOLD_TIME) milisecons

// Keyboard times
#define BTN_DEBOUNCE_TIME    200 // debounce time (*500us) to prevent flickering when pressing or releasing the button
#define BTN_HOLD_TIME       2000 // holding period (*500us) how long to wait for press+hold event
#define BTN_HOLD_TIME_WAIT  500 // Used for double key holding

#define TIMEOUT_MENU    1200000 // *500us = 10 mins
#define TIMEOUT_LASER   1200000
#define TIMEOUT_TEST     600000 // 5 min

// display menu
#define MENU_MAIN           1
#define MENU_ALARM          11
#define MENU_LOGIN          12
#define MENU_SETUP          2
#define MENU_SENSOR         21
#define MENU_GAIN1          211
#define MENU_THRE1          212
#define MENU_GAIN2          213
#define MENU_THRE2          214
#define MENU_SET            215
#define MENU_MODBUS         22
#define MENU_MODBUS_ID      221
#define MENU_MODBUS_SPEED   222
#define MENU_MODBUS_FORMAT  223
#define MENU_INFO           23
#define MENU_RESET          231


// configure measurement
#define MOTOR_SPEED         1000  // microseconds per mirror
#define ADC0_AVERAGING      4
#define ANALOG_BUFFER_SIZE  200

// Menu variables
volatile char         lastKey = BTN_NONE;        // Last key pressed
volatile boolean      flagHoldKey = false;       // Flag to ignore keys after a hold key
//volatile int lastSentTimeout = 0;
//volatile int lastPressTimeout = 0;
volatile int refreshMenuTimeout = 0;
volatile int laserTimeout = 0;
volatile int testTimeout = 0;
volatile int menuTimeout = 0;
volatile boolean dataSent = false;
int sendNextLn = 0;
volatile boolean blinkMenu = false;
volatile boolean alarmChecked = false;
volatile boolean extTest = false;
volatile boolean intTest = false;
volatile int currentMenu = MENU_MAIN;
volatile int currentMenuOption = 0;

// configure ADC
ADC *adc = new ADC(); // adc object

volatile int adc0_buffer[ANALOG_BUFFER_SIZE];     // ADC_0 8-bit resolution
volatile int peak[ANALOG_BUFFER_SIZE];
volatile int value_buffer[ANALOG_BUFFER_SIZE];
volatile int value_peak[ANALOG_BUFFER_SIZE];
volatile int adc0Value = 0;   //analog value
volatile int analogBufferIndex = 0; //analog buffer pointer
volatile int peakValue = 0;
volatile int peakValueDisp = 0;

volatile int thre256 = 75, thre = 30, thre1 = 30, thre2 = 50;
volatile int hmdThresholdHyst = 25;
volatile int pga = 16, pga1 = 16, pga2 = 32;

int celsius; // internal temp in deg of Celsius
int temp;    // internal ADC Temp channel value
int set = DEFAULT_SET;
const char* menu_setDisp[] = {"REL ", "REL1", "REL2", "MAN1", "MAN2"};
int setDispIndex = 0;
int menu_pga;
int menu_thre;
int menu_set;


// MODBUS

int modbusID = 1;
int menu_modbusID = 1;
int incID = 1;

const unsigned int modbusSpeedArray[] = {300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200};
int actualSpeed = 7; // array index
unsigned int modbusSpeed = modbusSpeedArray[actualSpeed];  // default 19200
unsigned int menu_modbusSpeed = modbusSpeedArray[actualSpeed];

const unsigned int modbusFormatArray[] = {SERIAL_8N1, SERIAL_8E1, SERIAL_8O1, SERIAL_8N2};
int actualFormat = 0;
unsigned int modbusFormat = modbusFormatArray[actualFormat];
unsigned int menu_modbusFormat = modbusFormatArray[actualFormat];
const char* menu_modbusFormatDisp[] = {"8N1", "8E1", "8O1", "8N2"};

// Timers
IntervalTimer adcTimer;   // timer stops randomly if defined as first
IntervalTimer timer500us; // timer for motor speed and various timeouts

int startTimerValue0 = 0;

// time counters for motor alarm
volatile int motorPulseIndex = 0;
volatile long motorTimeOld;
volatile long motorTimeNow;
volatile int motorTimeDiff;
volatile long peakValueTime = 0;
volatile long peakValueTimeDisp = 0;
volatile long adcResetTime;

// button interrupt
#define STATE_NORMAL 0
#define STATE_SHORT 1
#define STATE_LONG 2

volatile int  resultButtonA = STATE_NORMAL; // global value set by checkButton()
volatile int  resultButtonB = STATE_NORMAL; // global value set by checkButton()
volatile int BtnPressedATimeout = 0;
volatile int BtnPressedBTimeout = 0;
volatile boolean BtnReleasedA = false;
volatile boolean BtnReleasedB = false;

//menu login
int passwd = 0; // correct passwd is 1122
int nextBtn = 0;
boolean loggedIn = false;

void setup() {
  // initialize the LED display library:
  myDisplay.begin();
  // set the brightness of the display:
  myDisplay.setBrightness(brightness);
  //  myDisplay.home();
  //  myDisplay.print("Starting");
  displayPrint("Starting");
  delay(500);

  // initialize LEDs and I/O
  pinMode(PIN_BTN_A, INPUT_PULLUP);
  pinMode(PIN_BTN_B, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(PIN_BTN_A), checkButtonA, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_BTN_B), checkButtonB, CHANGE);

  pinMode(TEST_IN, INPUT_PULLUP);
  pinMode(SET_IN, INPUT_PULLUP);

  pinMode(LASER, OUTPUT);
  pinMode(IR_LED, OUTPUT);


  //pinMode(LED_BUILTIN, OUTPUT); //conflicts with SPI_CLK!!!
  pinMode(LED_POWER, OUTPUT);
  pinMode(LED_SIGNAL, OUTPUT);
  pinMode(LED_ALARM, OUTPUT);

  pinMode(OUT_SIGNAL, OUTPUT);
  pinMode(OUT_ALARM_NEG, OUTPUT);

  digitalWrite(LED_POWER, HIGH);
  digitalWrite(LED_SIGNAL, LOW);
  digitalWrite(OUT_SIGNAL,LOW);
  digitalWrite(LED_ALARM, HIGH);
  digitalWrite(OUT_ALARM_NEG, LOW); // opposite to LED_ALARM

  EEPROM_init();

  //initialize SPI

  pinMode(SPI_LATCH, OUTPUT);
  digitalWrite(SPI_LATCH, HIGH);
  SPI.begin();
  updateSPI(0,0);

  //initialize ADC

  ///// ADC0 ////
  // reference can be ADC_REF_3V3, ADC_REF_1V2 (not for Teensy LC) or ADC_REF_EXT.
  //adc->setReference(ADC_REF_1V2, ADC_0); // change all 3.3 to 1.2  if you change the reference to 1V2
  pinMode(A10, INPUT); // analog input P differential for PGA
  pinMode(A11, INPUT); // analog input N differential for PGA

  adc->setAveraging(ADC0_AVERAGING, ADC_0); // set number of averages
  adc->setResolution(8, ADC_0); // set bits of resolution

  // it can be ADC_VERY_LOW_SPEED, ADC_LOW_SPEED, ADC_MED_SPEED, ADC_HIGH_SPEED_16BITS, ADC_HIGH_SPEED or ADC_VERY_HIGH_SPEED
  // see the documentation for more information
  adc->setConversionSpeed(ADC_VERY_HIGH_SPEED); // change the conversion speed
  // it can be ADC_VERY_LOW_SPEED, ADC_LOW_SPEED, ADC_MED_SPEED, ADC_HIGH_SPEED or ADC_VERY_HIGH_SPEED
  adc->setSamplingSpeed(ADC_VERY_HIGH_SPEED); // change the sampling speed
  //adc->setReference(ADC_REF_3V3, ADC_0);

  adc->enablePGA(pga);

  // enable DMA and interrupts
  //adc->enableDMA(ADC_0);
  //NVIC_SET_PRIORITY( IRQ_ADC0, 32);
  //adc->enableInterrupts(ADC_0); // it's necessary to enable interrupts for PDB to work (why?)


  // ADC1 for internal temperature measurement

  adc->setAveraging(32, ADC_1); // set number of averages
  adc->setResolution(12, ADC_1); // set bits of resolution
  adc->setConversionSpeed(ADC_VERY_LOW_SPEED, ADC_1); // change the conversion speed
  adc->setSamplingSpeed(ADC_VERY_LOW_SPEED, ADC_1); // change the sampling speed
  //adc->setReference(ADC_REF_1V2, ADC_1);
  //delay(100);
  //adc->enableDMA(ADC_1);
  //NVIC_SET_PRIORITY( IRQ_ADC1, 160);
  //adc->enableInterrupts(ADC_1); // it's necessary to enable interrupts for PDB to work (why?)
  //adc->analogRead(readPin, ADC_0); // call this to setup everything before the pdb starts

  adc->analogReadDifferential(A10, A11, ADC_0);  //start ADC_0 differential
  adc->analogRead(ADC_TEMP_SENSOR, ADC_1); //start ADC_1 single, temp sensor

  // adc->enableInterrupts(ADC_0);
  // adc->startContinuousDifferential(A10, A11, ADC_0);
  // adc->startContinuous(ADC_TEMP_SENSOR, ADC_1);
  //Serial.println("End setup");



  Serial.begin(modbusSpeed);
  Serial1.transmitterEnable(TXEN);
  Serial1.begin(modbusSpeed, modbusFormat);
  Serial1.println("test RS485");

  //motor configuration and startup

  pinMode(22, OUTPUT);
  digitalWrite(22, LOW);    //motor enable
  pinMode(23, OUTPUT);      //motor output pulses

  pinMode(21, INPUT_PULLUP); //motor input pulses
  attachInterrupt(digitalPinToInterrupt(21), motor_isr, FALLING);

  
  //NVIC_SET_PRIORITY(IRQ_PORTC, 16);

  //motor slow start
  //timer500us.priority(0);

  for (int speed = 20; speed <= 100; speed++) {
    timer500us.end();
    startTimerValue0 = timer500us.begin(timer500us_isr, 50000 / speed);        //motor output pulses slowly going to 500us
    // Serial.println(startTimerValue0); // debug
    displayPrint("Mot=%3d%%", speed);
    delay(100);
  }

  for (int i = 0; i < ANALOG_BUFFER_SIZE; i++) {
    adc0_buffer[i] = 0;
    peak[i] = 0;
  }


  adc->startContinuousDifferential(A10, A11, ADC_0);
  adc->startContinuous(ADC_TEMP_SENSOR, ADC_1);
  adc->enableInterrupts(ADC_0);

  //startTimerValue0 = adcTimer.begin(adc0timer_callback, 5);

 
 
}



void loop() {

  // check SET
  checkSET();
  // check TEST
  checkTEST();
  // check ALARMS and WARNINGS
  checkALARM();  
  
  //show info on display
  displayMenu();
 
  //send data through USB "serial port", but Teensy is using USB speed 12Mbit/sec & buffered 
  //(on the PC side it uses serial port speed from setup)
  
  //if ( !dataSent && !lastSentTimeout) {  // send only every 5 sec
  
    //digitalWriteFast(LED_BUILTIN,HIGH);

    // if ( !dataSent && !lastSentTimeout && (Serial.availableForWrite() > 32)) {
    //   //Serial.println(value_buffer[i] * 100/ adc->adc0->getMaxValue(),DEC);
    //   Serial.print(sendNextLn);
    //   Serial.print(",");
    //   Serial.print(value_buffer[sendNextLn]);
    //   Serial.print(",");
    //   Serial.print(peakValueTimeDisp);
    //   Serial.print(",");
    //   Serial.print(value_peak[sendNextLn]);
    //   Serial.print(",");
    //   Serial.print(thre256);
    //   Serial.print(",");
    //   Serial.print(celsius, DEC);
    //   Serial.print(",");
    //   Serial.print(motorTimeDiff);
    //   Serial.print(",");
    //   Serial.println(Serial.availableForWrite());
    //   Serial.flush();
      
    //   if (sendNextLn < ANALOG_BUFFER_SIZE - 1) {
    //     sendNextLn++;
    //   } else {
    //     sendNextLn = 0;
    //     dataSent = true;
    //     lastSentTimeout = 1000;
        
    //   }
    // }

      //through 485 (slow, because "normal" serial port speed without buffering)
    if ( !dataSent && (Serial1.availableForWrite() > 32)) {  
      Serial1.print(sendNextLn);  // index
      Serial1.print(",");
      Serial1.print(value_buffer[sendNextLn]);
      Serial1.print(",");
      Serial1.print(peakValueTimeDisp);
      Serial1.print(",");
      Serial1.print(value_peak[sendNextLn]);
      Serial1.print(",");
      Serial1.print(thre256);
      
      Serial1.print(",");
      Serial1.print(motorTimeDiff);
      Serial1.print(",");
      Serial1.println(celsius, DEC);
      // Serial1.print(",");
      // Serial1.println(Serial1.availableForWrite());
      //Serial1.flush();
      
      if (sendNextLn < ANALOG_BUFFER_SIZE - 1) {  // index for data
        sendNextLn++;
      } else {
        //Serial1.flush();
        sendNextLn = 0;
        dataSent = true;
        //lastSentTimeout = 2000;
        
      }
    }
    

    //digitalWriteFast(LED_BUILTIN,LOW);


}

// Display print wrapper
int displayPrint(const char *format, ...) {
  char S[100];
  int Res;
  va_list arg;
  va_start(arg, format);
  Res = vsprintf(S, format, arg);
  va_end(arg);
  myDisplay.home();
  myDisplay.print(S);
  return Res;
}

// MENUS

void displayMenu(void) {
  if (!refreshMenuTimeout) {

   // button interrupt check

    switch (resultButtonA | resultButtonB) {

      case STATE_NORMAL: {
        lastKey = BTN_NONE;
        break;
      }

      case STATE_SHORT: {
        if ( resultButtonB != STATE_SHORT) {lastKey = BTN_A;} else {lastKey = BTN_B;}
        resultButtonA=STATE_NORMAL; resultButtonB=STATE_NORMAL;
        break;
      }

      case STATE_LONG:
      case 3: {
        if ( resultButtonA == STATE_LONG && resultButtonB == STATE_LONG) {lastKey = BTN_ABH;} 
        else if (resultButtonB != STATE_LONG) {lastKey = BTN_AH;} else {lastKey = BTN_BH;}
        resultButtonA=STATE_NORMAL; resultButtonB=STATE_NORMAL;
        break;
      default: break;
      }
    }

    


    //keyboard_scan();
    switch (currentMenu) {
      case MENU_ALARM: showAlarm();
      break;
      case MENU_MAIN: showMainMenu();
      break;
      case MENU_LOGIN: showLoginMenu();
      break;
      case MENU_SETUP: showSetupMenu();
      break;
      case MENU_SENSOR: showSensorMenu();
      break;
      case MENU_GAIN1: setGain1Menu();
      break;
      case MENU_THRE1: setThre1Menu();
      break;
      case MENU_GAIN2: setGain2Menu();
      break;
      case MENU_THRE2: setThre2Menu();
      break;
      case MENU_SET: setSetMenu();
      break;
      case MENU_MODBUS: showModbusMenu();
      break;
      case MENU_MODBUS_ID: setModbusID();
      break;
      case MENU_MODBUS_SPEED: setModbusSpeed();
      break;
      case MENU_MODBUS_FORMAT: setModbusFormat();
      break;
      case MENU_INFO: showInfoMenu();
      break;
      case MENU_RESET: showResetMenu();
      default: //showMainMenu();
      break;
    }
    refreshMenuTimeout = 500;
    blinkMenu = !blinkMenu;
    //blink LED_POWER
    digitalWriteFast(LED_POWER, !digitalReadFast(LED_POWER) );
  }
}


void showAlarm(void) {

  if (currentMenuOption == 0) {if (blinkMenu) displayPrint("ALARM!!!"); else displayPrint("MOTORerr");}
  if (currentMenuOption == 1) {if (blinkMenu) displayPrint("ALARM!!!"); else displayPrint("Temp %2dC", celsius);}
  if (currentMenuOption == 2) {if (blinkMenu) displayPrint("WARNING!"); else displayPrint("EXT_TEST");}
  if (currentMenuOption == 3) {if (blinkMenu) displayPrint("WARNING!"); else displayPrint("INT_TEST");}


  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A || lastKey == BTN_B) {
    currentMenu = MENU_MAIN;
    currentMenuOption = 0;
    alarmChecked = true;
    if (!menuTimeout) menuTimeout = TIMEOUT_MENU;
  }

}

// Main Menu View
void showMainMenu(void) {

  if (currentMenuOption == 0) displayPrint("Int %3d%%", (100 * peakValueDisp / 256) );
  else if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (currentMenuOption == 1) displayPrint("Gain %2dx", pga);
  if (currentMenuOption == 2) displayPrint("Thre %2d%%", thre);
  if (currentMenuOption == 3) displayPrint("Set %s", menu_setDisp[setDispIndex]);
  if (currentMenuOption == 4) {
    if (digitalReadFast(LASER)) {
      displayPrint("Laser ON");
    } else {
      displayPrint("LaserOFF");
    }
  }


  //keyboard_waitForAnyKey();
  //keyboard_scan();

  if (lastKey == BTN_A) {
    if (currentMenuOption > 0) currentMenuOption--;
    else currentMenuOption = 4;
  }
  if (lastKey == BTN_B) {
    if (currentMenuOption < 4) currentMenuOption++;
    else currentMenuOption = 0;
  }

  if (lastKey == BTN_BH) {

    if (currentMenuOption == 4) {
      laserTimeout = TIMEOUT_LASER;
      digitalWrite(LASER, !digitalRead(LASER));
    }


  }

  if (lastKey == BTN_ABH) {
    if (loggedIn) {currentMenu = MENU_SETUP; currentMenuOption = 0;}
    else {currentMenu = MENU_LOGIN; currentMenuOption = 0;}
  }
}

void showLoginMenu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (lastKey == BTN_A || lastKey == BTN_B) nextBtn++;

  switch (nextBtn) {
      case 0: displayPrint("PIN:    "); break;
      case 1: displayPrint("PIN:*   "); if (lastKey == BTN_B) passwd = passwd + 1000; break;
      case 2: displayPrint("PIN:**  "); if (lastKey == BTN_B) passwd = passwd + 100; break;
      case 3: displayPrint("PIN:*** "); if (lastKey == BTN_A) passwd = passwd + 20; break;
      case 4: displayPrint("PIN:****"); if (lastKey == BTN_A) passwd = passwd + 2; 
              delay(500);
              if (passwd == 1122) {
                currentMenu = MENU_SETUP;
                currentMenuOption = 0;
                displayPrint("PIN  OK!");
                delay(500);
                nextBtn = 0;
                passwd = 0;
                loggedIn = true;
              } else {
                displayPrint("BAD PIN!");
                delay(500);
                nextBtn = 0;
                passwd = 0;
                loggedIn = false;
                currentMenu = MENU_MAIN;
                currentMenuOption = 0;
              }
              break;
      default : break;
     }
}


void showSetupMenu(void) {

  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (currentMenuOption == 0) displayPrint("Sensor  ");
  if (currentMenuOption == 1) displayPrint("Modbus  ");
  if (currentMenuOption == 2) displayPrint("Info    ");
  if (currentMenuOption == 3) {
    if (digitalReadFast(IR_LED)) {
      displayPrint("Test  ON");
    } else {
      displayPrint("Test OFF");
    }
  }

  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (currentMenuOption > 0) currentMenuOption--;
    else currentMenuOption = 3;
  }
  if (lastKey == BTN_B) {
    if (currentMenuOption < 3) currentMenuOption++;
    else currentMenuOption = 0;
  }
  if (lastKey == BTN_AH) {
    currentMenu = MENU_MAIN;
    currentMenuOption = 0;
  }
  if (lastKey == BTN_BH) {
    if (currentMenuOption == 0) {
      currentMenu = MENU_SENSOR;
      currentMenuOption = 0;
    }
    if (currentMenuOption == 1) {
      currentMenu = MENU_MODBUS;
      currentMenuOption = 0;
    }
    if (currentMenuOption == 2) {
      currentMenu = MENU_INFO;
      currentMenuOption = 0;
    }
    if (currentMenuOption == 3) {
      testTimeout = TIMEOUT_TEST;
      intTest = !intTest;
      //currentMenu = MENU_SETUP;
      //currentMenuOption = 3;
    }
  }
  if (lastKey == BTN_ABH) {
    displayPrint("Logout !");
    passwd = 0;
    nextBtn = 0;
    loggedIn = false;
    delay(500);
    currentMenu = MENU_MAIN;
    currentMenuOption = 0;
  }
}

void showSensorMenu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (currentMenuOption == 0) displayPrint("Gain1 %2d", pga1);
  if (currentMenuOption == 1) displayPrint("Thre1 %2d", thre1);
  if (currentMenuOption == 2) displayPrint("Gain2 %2d", pga2);
  if (currentMenuOption == 3) displayPrint("Thre2 %2d", thre2);
  if (currentMenuOption == 4) displayPrint("Set %s", menu_setDisp[setDispIndex]);

  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (currentMenuOption > 0) currentMenuOption--;
    else currentMenuOption = 4;
  }
  if (lastKey == BTN_B) {
    if (currentMenuOption < 4) currentMenuOption++;
    else currentMenuOption = 0;
  }
  if (lastKey == BTN_AH) {
    currentMenu = MENU_SETUP;
    currentMenuOption = 0;
  }
  if (lastKey == BTN_BH) {
    if (currentMenuOption == 0) {
      currentMenu = MENU_GAIN1;
      currentMenuOption = 0;
      menu_pga = pga1; // local menu variable to avoid changes until saved
    }
    if (currentMenuOption == 1) {
      currentMenu = MENU_THRE1;
      currentMenuOption = 0;
      menu_thre = thre1; // local menu variable to avoid changes until saved
    }
    if (currentMenuOption == 2) {
      currentMenu = MENU_GAIN2;
      currentMenuOption = 0;
      menu_pga = pga2; // local menu variable to avoid changes until saved
    }
    if (currentMenuOption == 3) {
      currentMenu = MENU_THRE2;
      currentMenuOption = 0;
      menu_thre = thre2; // local menu variable to avoid changes until saved
    }
    if (currentMenuOption == 4) {
      currentMenu = MENU_SET;
      currentMenuOption = 0;
      menu_set = set; // local menu variable to avoid changes until saved
    }
  }
}

void setGain1Menu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (blinkMenu) displayPrint("Gain1 %2d", menu_pga); else displayPrint("      %2d", menu_pga);

  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (menu_pga > 1) menu_pga = menu_pga / 2;
    else menu_pga = 64;
  }
  if (lastKey == BTN_B) {
    if (menu_pga < 64) menu_pga = menu_pga * 2;
    else menu_pga = 1;
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_SENSOR;
    currentMenuOption = 0;
  }
  if (lastKey == BTN_ABH) { //SAVE
    pga1 = menu_pga;
    eeprom_writeInt(EE_ADDR_gain_set1, pga1);  //save to EEPROM
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_SENSOR;
    currentMenuOption = 0;
  }
}

void setThre1Menu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (blinkMenu) displayPrint("Thre1 %2d", menu_thre); else displayPrint("      %2d", menu_thre);

  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (menu_thre > 20) menu_thre = menu_thre - 10;
    else menu_thre = 80;
  }
  if (lastKey == BTN_B) {
    if (menu_thre < 80) menu_thre = menu_thre + 10;
    else menu_thre = 20;
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_SENSOR;
    currentMenuOption = 1;
  }
  if (lastKey == BTN_ABH) { // SAVE
    thre1 = menu_thre;
    eeprom_writeInt(EE_ADDR_threshold_set1, thre1);  //save to EEPROM
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_SENSOR;
    currentMenuOption = 1;
  }
}

void setGain2Menu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (blinkMenu) displayPrint("Gain2 %2d", menu_pga); else displayPrint("      %2d", menu_pga);

  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (menu_pga > 1) menu_pga = menu_pga / 2;
    else menu_pga = 64;
  }
  if (lastKey == BTN_B) {
    if (menu_pga < 64) menu_pga = menu_pga * 2;
    else menu_pga = 1;
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_SENSOR;
    currentMenuOption = 2;
  }
  if (lastKey == BTN_ABH) { //SAVE
    pga2 = menu_pga;
    eeprom_writeInt(EE_ADDR_gain_set2, pga2);  //save to EEPROM
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_SENSOR;
    currentMenuOption = 2;
  }
}

void setThre2Menu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (blinkMenu) displayPrint("Thre2 %2d", menu_thre); else displayPrint("      %2d", menu_thre);

  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (menu_thre > 20) menu_thre = menu_thre - 10;
    else menu_thre = 80;
  }
  if (lastKey == BTN_B) {
    if (menu_thre < 80) menu_thre = menu_thre + 10;
    else menu_thre = 20;
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_SENSOR;
    currentMenuOption = 3;
  }
  if (lastKey == BTN_ABH) { // SAVE
    thre2 = menu_thre;
    eeprom_writeInt(EE_ADDR_threshold_set2, thre2);  //save to EEPROM
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_SENSOR;
    currentMenuOption = 3;
  }
}

void setSetMenu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  switch (menu_set) { // display correct text
    case 0: setDispIndex = 0; // REL
    break;
    case 1: setDispIndex = 3; // MAN1
    break;
    case 2: setDispIndex = 4; // MAN2
    break;
    default:
    break;
  }

  if (blinkMenu) displayPrint("Set %s", menu_setDisp[setDispIndex]); else displayPrint("    %s", menu_setDisp[setDispIndex]);

  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (menu_set > 0) menu_set--; else menu_set = 2;
  }
  if (lastKey == BTN_B) {  // increment by 1
    if (menu_set < 2 ) menu_set++; else menu_set = 0;
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_SENSOR;
    currentMenuOption = 4;
  }
  if (lastKey == BTN_ABH) { // SAVE
    set = menu_set;
    eeprom_writeInt(EE_ADDR_set, set);  //save to EEPROM
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_SENSOR;
    currentMenuOption = 4;
  }
}


void showModbusMenu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (currentMenuOption == 0) displayPrint("ID   %3d", modbusID);
  if (currentMenuOption == 1) displayPrint("Sp%6d", modbusSpeed);
  if (currentMenuOption == 2) {
    for (int i = 0; i < 3; i++) { // find actual format in array
      if (modbusFormatArray[i] == modbusFormat) actualFormat = i;
    }
    displayPrint("Fmt  %s", menu_modbusFormatDisp[actualFormat]);
  }
  
  //keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (currentMenuOption > 0) currentMenuOption--;
    else currentMenuOption = 2;
  }
  if (lastKey == BTN_B) {
    if (currentMenuOption < 2) currentMenuOption++;
    else currentMenuOption = 0;
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_SETUP;
    currentMenuOption = 1;
  }
  if (lastKey == BTN_BH) { // ENTER

    if (currentMenuOption == 0) {
      currentMenu = MENU_MODBUS_ID;
      menu_modbusID = modbusID;
    } // read actual ID
    if (currentMenuOption == 1) {
      currentMenu = MENU_MODBUS_SPEED;
      menu_modbusSpeed = modbusSpeed;
      for (int i = 0; i < 11; i++) { // find actual speed in array
        if (modbusSpeedArray[i] == menu_modbusSpeed) actualSpeed = i;
      }
    }
    if (currentMenuOption == 2) {
      currentMenu = MENU_MODBUS_FORMAT;
      menu_modbusFormat = modbusFormat;
    }
  }
}


void setModbusID(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (blinkMenu) displayPrint("ID   %3d", menu_modbusID); else displayPrint("     %3d", menu_modbusID);

  // keyboard_waitForAnyKey();

  if (lastKey == BTN_BH) { // increment by 1 or 10
    if (incID == 1) {
      incID = 10;
      displayPrint("ID   x10");
      delay(500);
    } else {
      incID = 1;
      displayPrint("ID    x1");
      delay(500);
    }
  }

  if (lastKey == BTN_A) {  // decrement
    menu_modbusID = menu_modbusID - incID;
  }
  if (lastKey == BTN_B) {  // increment
    menu_modbusID = menu_modbusID + incID;
  }

  // check valid Modbus Slave ID range 1..247
  if (menu_modbusID < 1) menu_modbusID = 247;
  if (menu_modbusID > 247) menu_modbusID = 1;

  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_MODBUS;
    currentMenuOption = 0;
    incID = 1;
  }
  if (lastKey == BTN_ABH) { // SAVE
    modbusID = menu_modbusID;
    eeprom_writeInt(EE_ADDR_modbus_ID, modbusID);  //save to EEPROM
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_MODBUS;
    currentMenuOption = 0;
    //incID = 1;
  }
}

void setModbusSpeed(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (blinkMenu) displayPrint("Sp%6d", menu_modbusSpeed); else displayPrint("  %6d", menu_modbusSpeed);

  // keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (actualSpeed > 0) actualSpeed--; else actualSpeed = 11;
    menu_modbusSpeed = modbusSpeedArray[actualSpeed];
  }
  if (lastKey == BTN_B) {  // increment by 1
    if (actualSpeed < 11 ) actualSpeed++; else actualSpeed = 0;
    menu_modbusSpeed = modbusSpeedArray[actualSpeed];
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_MODBUS;
    currentMenuOption = 1;
  }
  if (lastKey == BTN_ABH) { // SAVE
    modbusSpeed = menu_modbusSpeed;
    eeprom_writeInt(EE_ADDR_modbus_Speed, modbusSpeed/100);  //save to EEPROM
    Serial.end();
    Serial.begin(modbusSpeed);
    Serial1.end();
    Serial1.transmitterEnable(TXEN);
    Serial1.begin(modbusSpeed, modbusFormat);
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_MODBUS;
    currentMenuOption = 1;
  }
}


void setModbusFormat(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (blinkMenu) displayPrint("Fmt  %s", menu_modbusFormatDisp[actualFormat]); else displayPrint("     %s", menu_modbusFormatDisp[actualFormat]);

  // keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {  // decrement by 1
    if (actualFormat > 0) actualFormat--; else actualFormat = 3;
    menu_modbusFormat = modbusFormatArray[actualFormat];
  }
  if (lastKey == BTN_B) {  // increment by 1
    if (actualFormat < 3) actualFormat++; else actualFormat = 0;
    menu_modbusFormat = modbusFormatArray[actualFormat];
  }
  if (lastKey == BTN_AH) { // ESC
    currentMenu = MENU_MODBUS;
    currentMenuOption = 2;
  }

  if (lastKey == BTN_ABH) { // SAVE
    modbusFormat = menu_modbusFormat;
    eeprom_writeInt(EE_ADDR_modbus_Format, modbusFormat);  //save to EEPROM
    Serial1.end();
    Serial1.transmitterEnable(TXEN);
    Serial1.begin(modbusSpeed, modbusFormat);
    displayPrint("SAVED!!!");
    delay(500);
    currentMenu = MENU_MODBUS;
    currentMenuOption = 2;
  }
}

void showInfoMenu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (currentMenuOption == 0) displayPrint("SHK01-%2d", MODEL_TYPE);
  if (currentMenuOption == 1) displayPrint("SN %2d%03d", MODEL_PROD_YEAR, MODEL_SERIAL_NUMBER);
  if (currentMenuOption == 2) displayPrint("FW %1d.%03d", FW_MAJOR_VERSION, FW_MINOR_VERSION);
  if (currentMenuOption == 3) displayPrint("FacReset");

  // keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (currentMenuOption > 0) currentMenuOption--;
    else currentMenuOption = 3;
  }
  if (lastKey == BTN_B) {
    if (currentMenuOption < 3) currentMenuOption++;
    else currentMenuOption = 0;
  }
  if (lastKey == BTN_AH) {
    currentMenu = MENU_SETUP;
    currentMenuOption = 2;
  }
  if (lastKey == BTN_BH) {
    if (currentMenuOption == 3) {
      currentMenu = MENU_RESET;
      currentMenuOption = 0;
    }
  }
}

void showResetMenu(void) {
  if (!menuTimeout) menuTimeout = TIMEOUT_MENU;

  if (currentMenuOption == 0) {if (blinkMenu) {displayPrint("Reset? N");} else {displayPrint("       N");}}
  if (currentMenuOption == 1) {if (blinkMenu) {displayPrint("Reset? Y");} else {displayPrint("       Y");}}

  // keyboard_waitForAnyKey();

  if (lastKey == BTN_A) {
    if (currentMenuOption > 0) currentMenuOption--;
    else currentMenuOption = 1;
  }
  if (lastKey == BTN_B) {
    if (currentMenuOption < 1) currentMenuOption++;
    else currentMenuOption = 0;
  }
  if (lastKey == BTN_AH) {
    currentMenu = MENU_INFO;
    currentMenuOption = 3;
  }
  if (lastKey == BTN_ABH) {
    if (currentMenuOption == 0) {
      currentMenu = MENU_INFO;
      currentMenuOption = 3;
    }
    if (currentMenuOption == 1) {
      config_writeDefaultsToEEPROM();
      config_loadFromEEPROM();
      //reset communication
      Serial.end();
      Serial.begin(modbusSpeed);
      Serial1.end();
      Serial1.transmitterEnable(TXEN);
      Serial1.begin(modbusSpeed, modbusFormat);

      displayPrint("RESET!!!");
      delay(500);
      currentMenu = MENU_INFO;
      currentMenuOption = 3;
    }
  }
}

// EEPROM

// Write a unsigned int (two bytes) value to eeprom
void eeprom_writeInt(unsigned int address, unsigned int value) {

  EEPROM.write(address, value % 256); // LSB
  EEPROM.write(address+1, value/256); // MSB

}

void eeprom_updateInt(unsigned int address, unsigned int value) {

  EEPROM.update(address, value % 256); // LSB
  EEPROM.update(address+1, value/256); // MSB

}
// read a unsigned int (two bytes) value from eeprom
unsigned int eeprom_readInt(unsigned int address) {

  return EEPROM.read(address)+EEPROM.read(address+1)*256;

}

void EEPROM_init() {

  if (
    eeprom_readInt(EE_ADDR_MODEL_TYPE) == MODEL_TYPE &&
    eeprom_readInt(EE_ADDR_MODEL_PROD_YEAR) == MODEL_PROD_YEAR &&
    eeprom_readInt(EE_ADDR_MODEL_SERIAL_NUMBER) == MODEL_SERIAL_NUMBER &&
    eeprom_readInt(EE_ADDR_FW_MAJOR_VERSION) == FW_MAJOR_VERSION &&
    eeprom_readInt(EE_ADDR_FW_MINOR_VERSION) == FW_MINOR_VERSION
    ) {

    // loads in ram the eeprom config
    config_loadFromEEPROM();
  }
  else {
    config_writeDefaultsToEEPROM();
    config_loadFromEEPROM();
  }
}

void config_loadFromEEPROM() {
 // loads in ram the eeprom config
    modbusID = eeprom_readInt(EE_ADDR_modbus_ID);
    modbusSpeed = eeprom_readInt(EE_ADDR_modbus_Speed)*100;  // speed/100 to fit 115200 in WORD
    modbusFormat = eeprom_readInt(EE_ADDR_modbus_Format);

    set = eeprom_readInt(EE_ADDR_set);
    pga1 = eeprom_readInt(EE_ADDR_gain_set1);
    thre1 = eeprom_readInt(EE_ADDR_threshold_set1);
    pga2 = eeprom_readInt(EE_ADDR_gain_set2);
    thre2 = eeprom_readInt(EE_ADDR_threshold_set2);
}

void config_writeDefaultsToEEPROM() {
    // writes sign codes
    eeprom_writeInt(EE_ADDR_MODEL_TYPE, MODEL_TYPE);
    eeprom_writeInt(EE_ADDR_MODEL_PROD_YEAR, MODEL_PROD_YEAR);
    eeprom_writeInt(EE_ADDR_MODEL_SERIAL_NUMBER, MODEL_SERIAL_NUMBER);
    eeprom_writeInt(EE_ADDR_FW_MAJOR_VERSION, FW_MAJOR_VERSION);
    eeprom_writeInt(EE_ADDR_FW_MINOR_VERSION, FW_MINOR_VERSION);

    // load defaults to ram and save on eeprom
    eeprom_writeInt(EE_ADDR_modbus_ID, DEFAULT_MODBUS_ID);
    eeprom_writeInt(EE_ADDR_modbus_Speed, DEFAULT_MODBUS_SPEED/100); // speed/100 to fit 115200 in WORD
    eeprom_writeInt(EE_ADDR_modbus_Format, DEFAULT_MODBUS_FORMAT);

    eeprom_writeInt(EE_ADDR_set, DEFAULT_SET);
    eeprom_writeInt(EE_ADDR_gain_set1, DEFAULT_GAIN_SET1);
    eeprom_writeInt(EE_ADDR_threshold_set1, DEFAULT_THRESHOLD_SET1);
    eeprom_writeInt(EE_ADDR_gain_set2, DEFAULT_GAIN_SET2);
    eeprom_writeInt(EE_ADDR_threshold_set2, DEFAULT_THRESHOLD_SET2);
}

// check SET and load proper settings
void checkSET() {
  switch (set) {
    case 0: if (digitalRead(SET_IN)) {pga = pga1; thre = thre1; setDispIndex = 1;}
            else {pga = pga2; thre = thre2; setDispIndex = 2;}
    break;
    case 1: pga = pga1; thre = thre1; setDispIndex = 3;
    break;
    case 2: pga = pga2; thre = thre2; setDispIndex = 4;
    break;
    default:
    break;
  }
  thre256 = thre * 256 / 100 - 1;
}

void checkTEST() {
  if (!digitalRead(TEST_IN)) extTest = true; else extTest = false;

  if (extTest || intTest) {
    digitalWrite(IR_LED,HIGH);
    if (blinkMenu) digitalWriteFast(LED_ALARM,HIGH); else digitalWriteFast(LED_ALARM,LOW);
  } else digitalWrite(IR_LED,LOW);
}


void checkALARM() {
  //check internal temperature
  temp = adc->adc1->readSingle();
  //celsius = (181964504 - 69971 * temp12) >> 12 ; //Vref 1.2
  celsius = 25.0 + 0.46977 * (892.43 - temp); //Vref 3.3

  //check alarms
  if ((motorTimeDiff > (6000 + 50)) || (motorTimeDiff < (6000 - 50))) { //motor alarm if not 6000us per rot.
    digitalWriteFast(LED_ALARM, HIGH);
    digitalWriteFast(OUT_ALARM_NEG, LOW); //negative output 0V=ALARM
    if (!alarmChecked) {
      currentMenu = MENU_ALARM;
      currentMenuOption = 0;
    }
  }     //set ALARM
  else if (celsius > 50) { // temp alarm
    digitalWriteFast(LED_ALARM, HIGH);
    digitalWriteFast(OUT_ALARM_NEG, LOW); //negative output 0V=ALARM
    if (!alarmChecked) {
      currentMenu = MENU_ALARM;
      currentMenuOption = 1;
    }
  } else if (extTest) {
    if (!alarmChecked) {
      currentMenu = MENU_ALARM;
      currentMenuOption = 2;
    }
  } else if (intTest && currentMenu != MENU_SETUP) {
    if (!alarmChecked) {
      currentMenu = MENU_ALARM;
      currentMenuOption = 3;
    }
  }
  else { // no alarm, no warnings
    digitalWriteFast(LED_ALARM, LOW); //no ALARM
    digitalWriteFast(OUT_ALARM_NEG, HIGH); //negative output: 24V=OK
    alarmChecked = false;
    if (currentMenu == MENU_ALARM) {currentMenu = MENU_MAIN; currentMenuOption =0;}
  }
}


// INTERRUPT ROUTINES

// motor (from HALL sensor) interrupt
void motor_isr(void) {

  adc->disableInterrupts(ADC_0);

  motorPulseIndex++;

  if (motorPulseIndex > 5) {  // one time per turn

    //check motor
    motorTimeOld = motorTimeNow;
    motorTimeNow = micros();
    motorTimeDiff = motorTimeNow - motorTimeOld;  // time of one rotation = 6000us
    motorPulseIndex = 0;
  } // one time per turn

  
  // check SIGNAL PRESENT
  if (peakValue > thre256) {
    digitalWriteFast(LED_SIGNAL, HIGH);
    digitalWriteFast(OUT_SIGNAL,HIGH);
  }

  if (peakValue < thre256 - hmdThresholdHyst) {
    digitalWriteFast(LED_SIGNAL, LOW);
    digitalWriteFast(OUT_SIGNAL, LOW);
  }

  peakValueDisp = peakValue;
  peakValueTimeDisp = peakValueTime;

  updateSPI((peakValueDisp<<8),(peakValueTimeDisp<<6));

  if (dataSent) { // prepare data for visualization
    for (int i = 0; i < ANALOG_BUFFER_SIZE; i++) {
      value_buffer[i] = adc0_buffer[i];
      value_peak[i] = peak[i];
    }
    dataSent = false;
  }

  // reset values
  peakValue = 0;
  peakValueTime = 0;
  // analogBufferIndex = 1+modbusID; // analog buffer from start + offset
  analogBufferIndex = 0; 


  for (int i = 0; i < ANALOG_BUFFER_SIZE; i++) {
    adc0_buffer[i] = 0;
    peak[i] = 0;
  }
  

  adc->enablePGA(pga);  // update PGA  
  adc->enableInterrupts(ADC_0);
}

// ADC interrupts
// called everytime a new value is converted. The DMA isr is called first
void adc0_isr(void) {
  // digitalWriteFast(LED_POWER, HIGH); //debug
  adc0Value = adc->adc0->readSingle();
  
  // check peak
  if (adc0Value > peakValue) {
    peakValue = adc0Value;
  }

  if (peakValue > thre256) {
    if (!peak[analogBufferIndex-1]) { // check for the first occurence
      peakValueTime = ((micros() - motorTimeNow) % 1000);   // 0-200 
      //peakValueTime = analogBufferIndex ;
    }
    peak[analogBufferIndex] = peakValue;
  }

  adc0_buffer[analogBufferIndex] = adc0Value;
  //increment buffer index
  if (analogBufferIndex < ANALOG_BUFFER_SIZE-1) {
    analogBufferIndex++;
  }
  else {
    analogBufferIndex = 0;
  }
  // digitalWriteFast(LED_POWER, LOW);  //debug
}



// Timer interrupts
void timer500us_isr(void) {   //every 500us
  //motor pulse
  digitalWriteFast(23, !digitalReadFast(23) );

  //update timeouts
  //if (lastSentTimeout) {lastSentTimeout--;}
  //if (lastPressTimeout) {lastPressTimeout--;}
  if (refreshMenuTimeout) {refreshMenuTimeout--;}
  if (laserTimeout) {laserTimeout--;} else {digitalWrite(LASER, LOW);}
  if (testTimeout) {testTimeout--;} else {intTest = false;}
  if (menuTimeout) {
    menuTimeout--;
    if (!menuTimeout) {
      currentMenu = MENU_MAIN;
      currentMenuOption = 0;
      alarmChecked = false;
      loggedIn = false;
    }
  }
  //buttons timeouts
  if (BtnPressedATimeout) {
    BtnPressedATimeout--;
    if (!BtnReleasedA && (BtnPressedATimeout < BTN_DEBOUNCE_TIME)) {
      resultButtonA = STATE_LONG; 
      BtnPressedATimeout = 0; 
      BtnReleasedA = false;
    }
    if (BtnReleasedA && (BtnPressedATimeout < (BTN_HOLD_TIME - BTN_DEBOUNCE_TIME))) {
      resultButtonA = STATE_SHORT; 
      BtnPressedATimeout = 0; 
      BtnReleasedA = false;
    }
  }
  
  if (BtnPressedBTimeout) {
    BtnPressedBTimeout--;
    if (!BtnReleasedB && (BtnPressedBTimeout < BTN_DEBOUNCE_TIME)) {
      resultButtonB = STATE_LONG; 
      BtnPressedBTimeout = 0; 
      BtnReleasedB = false;
    }
    if (BtnReleasedB && (BtnPressedBTimeout < (BTN_HOLD_TIME - BTN_DEBOUNCE_TIME))) {
      resultButtonB = STATE_SHORT; 
      BtnPressedBTimeout = 0; 
      BtnReleasedB = false;
    } 
  }
  
}
 
// SPI send 2 x 16 bit value
void updateSPI(int valueAN1, int valueAN2) {
  // gain control of the SPI port
  // and configure settings
  SPI.beginTransaction(SPISettings(2000000, MSBFIRST, SPI_MODE0)); // max 3.3MBPS, CPOL=0, CPHA=0
  digitalWrite(SPI_LATCH, LOW); // take LATCH pin LOW
  SPI.transfer16(valueAN2);
  SPI.transfer16(valueAN1);
  digitalWrite(SPI_LATCH, HIGH); // update DAC registers on AD420
  // release control of the SPI port
  SPI.endTransaction();
}

// void adc0timer_callback(void) {

//     adc->startSingleDifferential(A10, A11, ADC_0); // also: startSingleDifferential, analogSynchronizedRead, analogSynchronizedReadDifferential

// }


// button interrupts
//*****************************************************************
void checkButtonA() {
  /*
  * This function implements software debouncing for a two-state button.
  * It responds to a short press and a long press and identifies between
  * the two states. Your sketch can continue processing while the button
  * function is driven by pin changes.
  */
  if (digitalReadFast(PIN_BTN_A)) {
    if (BtnPressedATimeout) BtnReleasedA = true;
  }
  else {
    BtnReleasedA = false;
    BtnPressedATimeout = BTN_HOLD_TIME;
  }
}


//*****************************************************************
void checkButtonB() {
  /*
  * This function implements software debouncing for a two-state button.
  * It responds to a short press and a long press and identifies between
  * the two states. Your sketch can continue processing while the button
  * function is driven by pin changes.
  */
  if (digitalReadFast(PIN_BTN_B)) {
    if (BtnPressedBTimeout) BtnReleasedB = true;
  }
  else {
    BtnReleasedB = false;
    BtnPressedBTimeout = BTN_HOLD_TIME;
  }
}